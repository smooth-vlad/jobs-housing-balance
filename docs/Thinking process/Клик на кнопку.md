## root

### thinking
Обсуждаем клик внутри модулей UI

Нужно объяснить, как implementar клик в интерфейсе с учетом drag и необходимость управления событиями, как eventClick для предотвращения ложных срабатываний при перетаскивании. Мы обговорим типичные паттерны с флагами для подавления кликов и тонкости работы с событиями MouseUp, MouseDown, и Click.

Проработка кликов в коде UI

Кажется, можно использовать eventMouseUp с проверкой на dragDistance и использование p.Use для предотвращения событий. Нужно также учесть долгие нажатия и правые клики. Важно поддерживать фокус клавиатуры. Напоминаю, что тема стабильна, и изменения в API маловероятны, так что не стоит перегружать решение.

Поиск документации для UI кнопки

Сегодня я буду искать документацию по кнопкам UI в ColossalFramework. Нужно учесть события eventClick и их порядок, а также поднять примеры из модов для Cities: Skylines. Я посмотрю на моддинг-сообщества и GitHub для поддерживающих статей, чтобы узнать лучшие практики и уточнить детали событий.

Поиск документации по событию кнопки в UI

Рассматриваем документацию по UI

Результаты поиска немного смешанные, но я нашел документацию Paradox по ColossalFramework UI. Нужно разобраться, как корректно

Открытие документации по событиям UI в Paradox

Предложение открыть страницу на Read the Docs

Рассматриваем eventClick и drag threshold

Документация упоминает обработчик eventClick, но не раскрывает логику для drag threshold. Мы можем сосл

Ищем информацию по обработчикам событий и перетаскиванию

Прояснение событий click в UI

Кажется, существует путаница между eventClick и eventClicked в Colossal UI. Документация указывает на eventClick, но в потоке Simtropolis говорится про eventClicked. Похоже, нужно проверить, где используется свойство eventClicked, и уточнить, что является стандартом для UI-компонентов в CS. Поищу дополнительные источники.

Поиск информации о событии eventClick и eventClicked

Уточнение событий click

Не нашел никаких явных упоминаний о eventClicked в поиске, но заметил использование этого события в некоторых строках к

Анализируем динамичное поведение eventClicked и рекомендации

Рассмотрение подхода для обработки кликов

Документация по UUI не содержит подробностей по коду, но описывает использование кнопок и перетаскивания. Сейчас нужна более надежная методика для обработки кликов. Возможно, стоит ознакомиться с общими документами о событиях UI, например, "Как использовать ColossalFramework.UI" или про порядок событий "MouseDown->MouseUp". Поищу документы по "UIMouseEventParameter".

Поиск документации по обработке событий кликов UI

Рассмотрение событий мыши для UI

Есть хорошая статья с примерами кода, где используется eventClick для кнопки UI, и это важно для обработки событий, можно на нее сослаться. Также необходимо учесть обработку правого клика и долгого нажатия — возможно, стоит использовать eventMouseUpRight? Нужно проверить наличие eventDoubleClick или eventMouseUp для кнопок.

Поиск информации о событиях UI в ColossalFramework

Обработка кликов в UI

В источниках по веб-разработке указано, что нужно учитывать событие клика и действий с мышью с использованием пороговых значений. Исходя из этого, предложим два способа для реализации клика на кнопку:

1. Использовать eventClick с подавлением клика при перемещении (SuppressNextClick).
    
2. Альтернативный способ — использовать событие OnMouseUp без eventClick.
    

Предложения для кликов и перетаскивания

Для правильной обработки клика следует отслеживать движение и использовать пороговое значение для активации действия. Мы можем предложить две вариации: переопределить OnClick с использованием eventClick или обработать на OnMouseUp. Также важно добавить защиту от двойных кликов с помощью дебаунсинга.

Предложение для обработки клика и перетаскивания

Для правильной обработки клика на кнопку с учетом перетаскивания можно использовать eventClick. Важно задать флаг, чтобы избежать лишних кликов после перетаскивания. Для защиты от двойных кликов добавим задержку. Пример кода в C# для таких операций при OnMouseUp и eventClick.

Рассматривая обработку событий

Мы можем использовать паттерн eventKeyDown для захвата событий клика в capture режиме. Также стоит упомянуть обработку правого клика с eventMouseUp, где p.buttons==Right. Возможно, существует событие eventDoubleClick для UIComponent, стоит проверить это. Нужно удостовериться, есть ли именно eventDoubleClick в ColossalFramework.UIComponent.

Поиск документации и примеров обработки кликов

Предлагая два варианта обработки клика

Мы будем использовать паттерны из документации и кода на "note.com", чтобы прописать обработку событий клика. В ответе на русском языке предложим два варианта:

- Вариант A: использовать eventClick с флагом подавления.
    
- Вариант B: обрабатывать клик в MouseUp, если dragDistance <= threshold.
    

Также стоит упомянуть использование p.Use() для предотвращения распространения события и добавить реализацию двойного клика через Time.realtimeSinceStartup.

Searching for eventDoubleClick support in Colossal UI

### Ответ 
Коротко: в Colossal UI «клик» обычно делают через `eventClick` у `UIButton` **и** глушат его, если во время зажатой ЛКМ был драг больше порога. Это самый распространённый паттерн у мододелов CS1. Документация и треды показывают именно привязку обработчика `eventClick` к компоненту, а в живых примерах модов (горячие клавиши и т.п.) `eventClick` используют как триггер UI-логики.

Вот компактный вариант, который «садится» на твой drag-код:

```csharp
public sealed class DraggableButton : UIButton
{
    private bool _dragging;
    private Vector2 _dragStartLocalInParent;
    private Vector2 _dragStartRel;
    private bool _suppressNextClick;
    private const float DragThreshold = 6f;   // px в координатах родителя
    private float _nextClickAt;
    private const float ClickCooldown = 0.15f; // анти-даблклик/спам

    public override void Start()
    {
        base.Start();
        text = "★";
        size = new Vector2(36f, 36f);

        eventMouseDown += (c, p) =>
        {
            if (p.buttons != UIMouseButton.Left) return;
            _dragging = true;
            _dragStartRel = relativePosition;
            _dragStartLocalInParent = ScreenToParentLocal(Input.mousePosition);
            _suppressNextClick = false;
            BringToFront();
            p.Use();
        };

        eventMouseMove += (c, p) =>
        {
            if (!_dragging) return;

            Vector2 curLocal = ScreenToParentLocal(Input.mousePosition);
            Vector2 delta = curLocal - _dragStartLocalInParent;

            // если за время drag превысили порог — клик потом игнорируем
            if (!_suppressNextClick && delta.sqrMagnitude > DragThreshold * DragThreshold)
                _suppressNextClick = true;

            // учёт масштаба родителя (если кто-то скейлит панель)
            var pr = (parent ?? (UIComponent)UIView.GetAView()).transform.lossyScale;
            if (pr.x != 0f && pr.y != 0f) delta = new Vector2(delta.x / pr.x, delta.y / pr.y);

            relativePosition = ClampToScreen(_dragStartRel + delta);
            p.Use();
        };

        eventMouseUp += (c, p) =>
        {
            if (p.buttons == UIMouseButton.Left) _dragging = false;
            p.Use();
        };

        // «Обычный» клик
        eventClick += (c, p) =>
        {
            // если только что был drag — не триггерим клик
            if (_suppressNextClick) { _suppressNextClick = false; p.Use(); return; }

            // анти-даблклик/спам, чтобы не вызывалось дважды
            if (Time.realtimeSinceStartup < _nextClickAt) { p.Use(); return; }
            _nextClickAt = Time.realtimeSinceStartup + ClickCooldown;

            OnButtonActivated(); // твоя логика
            p.Use();
        };
    }

    private void OnButtonActivated()
    {
        // TODO: открыть панель/переключить режим/что угодно
        Debug.Log("[MyMod] Button clicked!");
    }

    private Vector2 ScreenToParentLocal(Vector3 mouseScreen)
    {
        var par = (parent ?? (UIComponent)UIView.GetAView());
        var ui = par.GetUIView();
        Vector2 gui = ui.ScreenPointToGUI(mouseScreen); // учитывает DPI/UI Scale
        return par.ScreenToLocal(gui);
    }

    private Vector2 ClampToScreen(Vector2 pos)
    {
        var ui = parent ?? UIView.GetAView();
        float maxX = Mathf.Max(0f, ui.width  - width);
        float maxY = Mathf.Max(0f, ui.height - height);
        return new Vector2(Mathf.Clamp(pos.x, 0f, maxX), Mathf.Clamp(pos.y, 0f, maxY));
    }
}
```

Почему так «принято»

- `eventClick` — штатный делегат ввода в Colossal UI (доки прямо показывают `eventClick += FooBarClickHandler;`). Он надёжно стреляет после `MouseDown`→`MouseUp` на том же контроле.
    
- В треде про добавление кнопки моддеры вешают обработчик клика так же (и обсуждают родителя/атласы).
    
- В реальном коде модов `eventClick` используют как триггер для входа в состояние или запуска захвата ввода (настройка хоткеев и т.п.).
    

Альтернатива (тоже часто встречается): «клик на MouseUp»  
Если хочешь полностью контролировать логику и вообще не полагаться на `eventClick`, можно делать так: в `eventMouseUp` проверять, что ЛКМ отпущена, а суммарная дельта меньше порога → считать это кликом и вызывать `OnButtonActivated()`. Это эквивалентно, но чуть многословнее.

Ещё две мелочи из практики:

- **Правый клик/контекст**: фильтруй `p.buttons == UIMouseButton.Right` в `eventMouseUp` — удобно для ресета позиции/открытия меню.
    
- **Фокус и клавиатура**: если по клику ты хочешь ловить `Esc`/буквы, вызови `Focus()` и подпишись на `eventKeyDown` в обработчике клика, как делают в примерах с назначением горячих клавиш.
    

Если нужно, покажу минимальный вариант «MouseUp-клик» или добавлю даблклик-детектор по таймеру. Ниже — источники, где именно так и делают/описывают:

- Официальные моддинг-доки: примеры с `eventClick` и раздел про input events.
    
- Обсуждение «How to add UI button?» с паттерном подписки клика и выбором родителя (`UIView.GetAView()` и т.д.).
    
- Живой пример, где по `eventClick` кнопка переводит UI в режим захвата клавиш (привязка хоткеев) — типичный паттерн для модов CS1.